. Program to Implement 8-Puzzle problem using Python.
Procedure
1. Flatten the board into a tuple (immutable, so it can be stored in a dictionary).
•2. Store this tuple in a dictionary (dict) where the value is the number of moves taken to reach it.
3. Perform BFS level by level:
• Expand all nodes at depth cnt.
• Generate all valid next moves by sliding the 0 (blank space).
• If the goal state (0,1,2,3,4,5,6,7,8) is found → return the number of moves.
4. If no solution exists, return -1.
Program
class Solution:
   def solve(self, board):
       state_dict = {}
       flatten = []
 
       # Flatten the board
       for i in range(len(board)):
           flatten += board[i]
       flatten = tuple(flatten)
 
       # Store initial state
       state_dict[flatten] = 0
 
       # Goal state
       if flatten == (0, 1, 2, 3, 4, 5, 6, 7, 8):
           return 0
 
       return self.get_paths(state_dict)
 
   def get_paths(self, state_dict):
       cnt = 0
       while True:
           # Nodes at current depth
           current_nodes = [x for x in state_dict if state_dict[x] == cnt]
 
           if len(current_nodes) == 0:
               return -1  # no solution
 
           for node in current_nodes:
               next_moves = self.find_next(node)
               for move in next_moves:
                   if move not in state_dict:
                       state_dict[move] = cnt + 1
                       if move == (0, 1, 2, 3, 4, 5, 6, 7, 8):
                           return cnt + 1
           cnt += 1
 
   def find_next(self, node):
       # Possible moves for each index of 0
       moves = {
           0: [1, 3],
           1: [0, 2, 4],
           2: [1, 5],
           3: [0, 4, 6],
           4: [1, 3, 5, 7],
           5: [2, 4, 8],
           6: [3, 7],
           7: [4, 6, 8],
           8: [5, 7],
       }
 
       results = []
       pos_0 = node.index(0)  # position of the blank
 
       for move in moves[pos_0]:
           new_node = list(node)
           # Swap 0 with the chosen move
           new_node[move], new_node[pos_0] = new_node[pos_0], new_node[move]
           results.append(tuple(new_node))
 
       return results
 
 
# Test
ob = Solution()
matrix = [
   [3, 1, 2],
   [4, 7, 5],
   [6, 8, 0]
]
print(ob.solve(matrix))  # prints minimum number of moves
 
 
5. Program to Implement Water-Jug problem using Python.
Procedure
1.  Start from the initial state (0,0) → both jugs empty.
2. Use a queue (FIFO) to store states and their paths.
3.  Maintain a visited set to avoid repeating states.
4.  At each step, generate all possible states by applying the operations:
• Fill Jug1
• Fill Jug2
• Empty Jug1
• Empty Jug2
• Pour Jug1 → Jug2
• Pour Jug2 → Jug1
5.  If at any state, the amount of water in Jug1 or Jug2 equals the target d, stop and return the path.
6.  If the queue becomes empty, it means no solution exists.
 
Program
from collections import deque
 
def water_jug_bfs(jug1_capacity, jug2_capacity, target):
   # Initial state (both jugs empty)
   start = (0, 0)
 
   # Queue for BFS
   q = deque([(start, [])])  # (state, path of states)
 
   # Visited states to avoid repetition
   visited = set([start])
 
   while q:
       (x, y), path = q.popleft()
 
       # If we reach target
       if x == target or y == target:
           return path + [(x, y)]
 
       # All possible operations
       possible_states = [
           (jug1_capacity, y),  # Fill Jug1
           (x, jug2_capacity),  # Fill Jug2
           (0, y),             # Empty Jug1
           (x, 0),             # Empty Jug2
           # Pour Jug1 -> Jug2
           (max(0, x - (jug2_capacity - y)), min(jug2_capacity, y + x)),
           # Pour Jug2 -> Jug1
           (min(jug1_capacity, x + y), max(0, y - (jug1_capacity - x))),
       ]
 
       for state in possible_states:
           if state not in visited:
               visited.add(state)
               q.append((state, path + [(x, y)]))
 
   return None  # No solution
 
 
# Example usage
if __name__ == "__main__":
   jug1_capacity = 4
   jug2_capacity = 3
   target = 2
 
   result = water_jug_bfs(jug1_capacity, jug2_capacity, target)
 
   if result:
       print("Solution found:")
       for step in result:
           print(step)
   else:
       print("No solution exists.")
 